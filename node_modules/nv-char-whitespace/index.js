const {CODE_DICT,CH_DICT} = require("nv-char-basic");

const line_break_regexp = /\r\n?|[\n\u2028\u2029]/; 
module.exports.line_break_regexp = line_break_regexp;
module.exports.line_break_regexp_g = new RegExp(line_break_regexp.source, "g");

function is_nl_code(code) {
  switch (code) {
    case CODE_DICT.lineFeed:
    case CODE_DICT.carriageReturn:
    case CODE_DICT.lineSeparator:
    case CODE_DICT.paragraphSeparator:
      return true;
    default:
      return false;
  }
}

function is_nl(ch) {
  switch (ch) {
    case CH_DICT.lineFeed:
    case CH_DICT.carriageReturn:
    case CH_DICT.lineSeparator:
    case CH_DICT.paragraphSeparator:
      return true;
    default:
      return false;
  }
}


const NL_CODE_ARR = [
    CODE_DICT.lineFeed,
    CODE_DICT.carriageReturn,
    CODE_DICT.lineSeparator,
    CODE_DICT.paragraphSeparator
]

const NL_CH_ARR = NL_CODE_ARR.map(r=>String.fromCharCode(r))


module.exports.NL_CODE_ARR = NL_CODE_ARR;
module.exports.NL_CH_ARR = NL_CH_ARR;
module.exports.is_nl_code = is_nl_code;
module.exports.is_nl = is_nl;



module.exports.skip_white_space_regexp = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

function is_non_nl_ws_code(code) {
  switch (code) {
    case 0x0009: // CHARACTER TABULATION
    case 0x000b: // LINE TABULATION
    case 0x000c: // FORM FEED
    case CODE_DICT.space:
    case CODE_DICT.nonBreakingSpace:
    case CODE_DICT.oghamSpaceMark:
    case 0x2000: // EN QUAD
    case 0x2001: // EM QUAD
    case 0x2002: // EN SPACE
    case 0x2003: // EM SPACE
    case 0x2004: // THREE-PER-EM SPACE
    case 0x2005: // FOUR-PER-EM SPACE
    case 0x2006: // SIX-PER-EM SPACE
    case 0x2007: // FIGURE SPACE
    case 0x2008: // PUNCTUATION SPACE
    case 0x2009: // THIN SPACE
    case 0x200a: // HAIR SPACE
    case 0x202f: // NARROW NO-BREAK SPACE
    case 0x205f: // MEDIUM MATHEMATICAL SPACE
    case 0x3000: // IDEOGRAPHIC SPACE
    case 0xfeff: // ZERO WIDTH NO-BREAK SPACE
      return true;
    default:
      return false;
  }
}

module.exports.is_non_nl_ws_code = is_non_nl_ws_code;

function is_non_nl_ws(ch) {
  switch (ch) {
    case CH_DICT.tab:
    case CH_DICT.lineTab: 
    case CH_DICT.formFeed: 
    case CH_DICT.space:
    case CH_DICT.nonBreakingSpace:
    case CH_DICT.oghamSpaceMark:
    case CH_DICT.enQuad: 
    case CH_DICT.emQuad: 
    case CH_DICT.enSpace: 
    case CH_DICT.emSpace: 
    case CH_DICT.threePerEmSpace: 
    case CH_DICT.fourPerEmSpace: 
    case CH_DICT.sixPerEmSpace: 
    case CH_DICT.figureSpace: 
    case CH_DICT.punctuationSpace: 
    case CH_DICT.thinSpace: 
    case CH_DICT.hairSpace: 
    case CH_DICT.narrowNoBreakSpace: 
    case CH_DICT.mediumMathematicalSpace: 
    case CH_DICT.ideographicSpace: 
    case CH_DICT.zeroWidthNoBreakSpace: 
      return true;
    default:
      return false;
  }
}

module.exports.is_non_nl_ws = is_non_nl_ws;

const NON_NL_WS_CODE_ARR = [
    CODE_DICT.tab,CODE_DICT.lineTab,CODE_DICT.formFeed,
    CODE_DICT.space,CODE_DICT.nonBreakingSpace,CODE_DICT.oghamSpaceMark,
    CODE_DICT.enQuad,CODE_DICT.emQuad,CODE_DICT.enSpace,CODE_DICT.emSpace,
    CODE_DICT.threePerEmSpace,CODE_DICT.fourPerEmSpace,CODE_DICT.sixPerEmSpace,
    CODE_DICT.figureSpace,
    CODE_DICT.punctuationSpace,
    CODE_DICT.thinSpace,
    CODE_DICT.hairSpace,
    CODE_DICT.narrowNoBreakSpace,
    CODE_DICT.mediumMathematicalSpace,
    CODE_DICT.ideographicSpace,
    CODE_DICT.zeroWidthNoBreakSpace
]


module.exports.NON_NL_WS_CODE_ARR = NON_NL_WS_CODE_ARR;

const NON_NL_WS_CH_ARR = NON_NL_WS_CODE_ARR.map(r=>String.fromCharCode(r));
module.exports.NON_NL_WS_CH_ARR = NON_NL_WS_CH_ARR;




function is_ws_code(code) {return(is_non_nl_ws_code(code) || is_nl_code(code))}
function is_ws(ch) {return(is_non_nl_ws(ch) || is_nl(ch))}

module.exports.is_ws_code = is_ws_code;
module.exports.is_ws = is_ws;

module.exports.WS_CHCODE_ARR = NL_CODE_ARR.concat(NON_NL_WS_CODE_ARR);
module.exports.WS_CH_ARR = NL_CH_ARR.concat(NON_NL_WS_CH_ARR);


const STATE_DICT = {
    init:0,
    executing:1,
    succ:2,
    eof:3
}

module.exports.STATE_DICT = STATE_DICT;

function from_generator(g,extra_st = new Set()) {
    let d = {
        g,
        rslt:"",
        state:STATE_DICT.init,
    }
    ////
    let ch = (d.g.next()).value;
    if(ch === undefined) {
        d.state = STATE_DICT.eof;
        return(d)
    }
    ////
    while(ch!== undefined && (is_ws(ch) || extra_st.has(ch))) {
        ch = d.g.next().value;
    }
    ////
    while(ch !== undefined  && !is_ws(ch) && !extra_st.has(ch)) {
        d.rslt = d.rslt + ch;
        ch = d.g.next().value;
    }
    if(ch === undefined) {
        d.state = STATE_DICT.eof;
    } else if(is_ws(ch) || extra_st.has(ch)) { 
        d.state = STATE_DICT.succ;
    } else {
        //impossible
    }
    return(d)
}

function from_charr(arr,pos=0,extra_st = new Set()) {
    let d = {
        arr:arr,
        pos:pos,
        rslt:"",
        state:STATE_DICT.init,
    }
    for(let i=d.pos;i<arr.length;i++) {
        let ch = arr[i]
        let cond = is_ws(ch) || extra_st.has(ch)
        if(cond) {d.pos = d.pos+1} else {break}
    }
    let si = d.pos;
    for(let i=d.pos;i<arr.length;i++) {
        let ch = arr[i]
        let cond = !is_ws(ch) && !extra_st.has(ch)
        if(cond) {d.pos = d.pos+1} else {break}
    }
    if(d.pos === arr.length) {d.state = STATE_DICT.eof} else {d.state = STATE_DICT.succ;}
    d.rslt = arr.slice(si,d.pos).join("");
    return(d)
}

module.exports.from_generator = from_generator;
module.exports.from_charr = from_charr;

