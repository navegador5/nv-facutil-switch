nv-facutil-basic
===============
- nv-facutil-basic    


install
=======
- npm install nv-facutil-basic 

usage
=====
    
example
-------

    const fac_bsc = require("nv-facutil-basic");

    > fac_bsc.is_node()
    true
    >
    > var d = {a:{b:{c:200}}}

    > fac_bsc.optional_chaining(d,'a','b')
    { c: 200 }
    > fac_bsc.optional_chaining(d,'a','b','e','c')
    undefined
    >
    > fac_bsc.nullish(null,200)
    200
    > fac_bsc.nullish(undefined,200)
    200
    > fac_bsc.nullish(false,200)
    false
    > fac_bsc.nullish(true,200)
    true
    >

    class Cls {
        constructor(){
            this.tag="div"
        }
    }

    function repr(that,stag,etag) {
        return(stag+that.tag+etag)
    }

    fac_bsc.add_repr(Cls,repr,'<','>')
    > var o = new Cls()
    undefined
    > o
    <div>
    >


    > var s = `
    ... aaa
    ... bbb
    ... ccc
    ... `
    >
    
    > s
    '\naaa\nbbb\nccc\n'
    >
    
    
    > console.log(fac_bsc.indent(s,2))
    
            aaa
            bbb
            ccc
    
    
    > console.log(fac_bsc.indent(s,2,"\t"))
    
                    aaa
                    bbb
                    ccc
    
    > console.log(fac_bsc.indent(s,3,"@"))
    @@@
    @@@aaa
    @@@bbb
    @@@ccc
    @@@
    
    >


    > class SomeCls {}
    undefined
    > fac_bsc.add_string_tag(SomeCls,that=>'kkk')
    undefined
    > var o = new SomeCls()
    undefined
    > o
    SomeCls [kkk] {}
    >


    > fac_bsc.creat_id()
    '5055a812-2b24-4c9e-ab11-87088e51203c'
    > fac_bsc.get_abbr('5055a812-2b24-4c9e-ab11-87088e51203c')
    '5055a812'
    >
    
    fac_bsc.creat_reserved(['EPSILON','ε'],['LAMBDA','λ'])
    
    > EPSILON
    'ε'
    > LAMBDA
    'λ'
    > Object.getOwnPropertyDescriptors(global).EPSILON
    { value: 'ε', writable: false, enumerable: false, configurable: false }
    > Object.getOwnPropertyDescriptors(global).LAMBDA
    { value: 'λ', writable: false, enumerable: false, configurable: false }
    >


### iflet

    var a = 3

    var x = iflet(
        a<=1,100,
        a<=2,200,
        300
    )

    >300


### ifrtrn

    var condf0 = (ctx)=>  (ctx.a<ctx.b);
    var condf1 = (ctx)=>  (ctx.a>ctx.b);

    var actf0  = (ctx)=>(ctx.b-ctx.a);
    var actf1  = (ctx)=>(ctx.a-ctx.b);
    var dfltf  = (ctx)=> 0;

    ifrtrn(
       ctx,              //data-ctx
       condf0,actf0,     // cond : action
       condf1,actf1,     // cond : action
       dfltf             // otherwise-action
    )

    >1
    >

### ifdo similiar to ifrtrn, but write-the-return-value to ctx

    var ctx = {a:2,b:3,_rslt:-1}

    var condf0 = (ctx)=>  (ctx.a<ctx.b);
    var condf1 = (ctx)=>  (ctx.a>ctx.b);

    var actf0  = (ctx)=>(ctx._rslt = ctx.b-ctx.a);
    var actf1  = (ctx)=>(ctx._rslt = ctx.a-ctx.b);
    var dfltf  = (ctx)=>(ctx._rslt =0);


    ifdo(
       ctx,              //data-ctx
       condf0,actf0,     // cond : action
       condf1,actf1,     // cond : action
       dfltf             // otherwise-action
    );

    > ctx
    { a: 2, b: 3, _rslt: 1 }
    >


### creat\_ifgoto;  
- to avoid using while/for
- while/for is hard for auto-generate code in runtime

#### 

     var condf0 = (ctx)=>(ctx.idx %7===0) ;
     var condf1 = (ctx)=>(ctx.idx %7===1) ;
     var condf2 = (ctx)=>(ctx.idx %7===2) ;



     var action0 = (ctx)=>{
         ctx.zero.add(ctx.idx);
         ctx.idx=parseInt(Math.random()*1000)
     }
     var action1 = (ctx)=>{
         ctx.one.add(ctx.idx);
         ctx.idx=parseInt(Math.random()*1000)
     }
     var action2 = (ctx)=>{
         ctx.two.add(ctx.idx);
         ctx.idx=parseInt(Math.random()*1000)
     }
     var action_dflt = (ctx)=>{
         ctx.other.add(ctx.idx);
         ctx.idx=parseInt(Math.random()*1000);
         if(ctx.other.size>2) {
             ctx.__break()
         } else {
             ctx.__goto(0)
         }
     }


     var ifgoto = creat_ifgoto(
         condf0,action0,
         condf1,action1,
         condf2,action2,
         action_dflt
     );

     /*
     > ifgoto.builtin
     [
       [Function: __goto],
       [Function: __goto_fst],
       [Function: __goto_lst],
       [Function: __continue],
       [Function: __break],
       [Function: __prev]
     ]
     >

     > ifgoto.reset
     [Function: reset]
     >

     */



     var ctx = {
         idx:0,
         zero:new Set(),
         one:new Set(),
         two:new Set(),
         other:new Set()
     }



     > ifgoto(ctx)
     {
       idx: 182,
       zero: Set(1) { 0 },
       one: Set(1) { 498 },
       two: Set(0) {},
       other: Set(3) { 494, 867, 273 },
       __goto: [Function: __goto],
       __goto_fst: [Function: __goto_fst],
       __goto_lst: [Function: __goto_lst],
       __continue: [Function: __continue],
       __break: [Function: __break],
       __prev: [Function: __prev]
     }


     var ctx = {
         idx:0,
         zero:new Set(),
         one:new Set(),
         two:new Set(),
         other:new Set()
     }

     ifgoto.reset()              //must reset run-enviroment before resuing

     /*
     > ifgoto.reset()       //must reset run-enviroment before resuing

     > ifgoto(ctx)
     {
       idx: 370,
       zero: Set(1) { 0 },
       one: Set(2) { 785, 820 },
       two: Set(1) { 163 },
       other: Set(4) { 231, 305, 230, 368 },
       __goto: [Function: __goto],
       __goto_fst: [Function: __goto_fst],
       __goto_lst: [Function: __goto_lst],
       __continue: [Function: __continue],
       __break: [Function: __break],
       __prev: [Function: __prev]
     }
     >


     */



### forof

    > var o = {a:100,b:200}
    > for(let e of forof(o)) {console.log(e)}
    [ 100,'a' ]
    [ 200,'b' ]

### forlst
    
    > x.forlst([10,20,30,40],(r,i)=>console.log(r,i))
    40 3
    30 2
    20 1
    10 0
    undefined
    >



### mirror

    > fac_bsc.mirr([11,21,31])
    SimpleMirr(6) [Map] {
      0 => 11,
      11 => 0,
      1 => 21,
      21 => 1,
      2 => 31,
      31 => 2
    }
    > fac_bsc.mirr({a:11,b:21,c:31})
    SimpleMirr(6) [Map] {
      'a' => 11,
      11 => 'a',
      'b' => 21,
      21 => 'b',
      'c' => 31,
      31 => 'c'
    }
    >


### json

    var ary=[[1,2],3,[4,[[6]]]]
    jrplc(d,(r)=>r*2)
    console.log(ary)
    //[[2,4],6,[8,[[12]]]]
    
    var d = {1:100,x:{2:{3:300}}}
    jrplc(d,(r,i,k)=>r+k)
    console.log(d)
    //{ '1': '1001', x: { '2': { '3': '3003' } } }


    > jflat(foo)
    [
      [ [ 'foundation' ], 'Mozilla' ],
      [ [ 'model' ], 'box' ],
      [ [ 'd', 'week' ], 45 ],
      [ [ 'd', 'transport' ], 'car' ],
      [ [ 'd', 'month' ], 7 ],
      [ [ 'ary', 0 ], 10 ],
      [ [ 'ary', 2 ], 30 ],
      [ [ 'ary', 1, 'v' ], 20 ]
    ]
    >



    > var g = jgen(foo)
    > var [val,index,key,parent,is_prop,is_ele] = (g.next().value)
    > val
    {
      foundation: 'Mozilla',
      model: 'box',
      d: { week: 45, transport: 'car', month: 7 },
      ary: [ 10, { v: 20 }, 30 ]
    }
    > index
    Symbol(noexist)
    > key
    Symbol(noexist)
    > parent
    Symbol(noexist)
    > is_prop
    false
    > is_ele
    false
    >
    > var [val,index,key,parent,is_prop,is_ele] = (g.next().value)
    > val
    'Mozilla'
    > index
    0
    > key
    'foundation'
    > parent
    {
      foundation: 'Mozilla',
      model: 'box',
      d: { week: 45, transport: 'car', month: 7 },
      ary: [ 10, { v: 20 }, 30 ]
    }
    > is_prop
    true
    > is_ele
    false
    >

     



### fary, fchain

    > const f1 = (a)=>a+1;
    undefined
    > const f2 = (a)=>a*2;
    undefined
    > const f3 = (a)=>a-1;
    undefined
    > fchain(5,f1,f2,f3)
    11
    > fary([f1,f2,f3],5)
    11
    > f3(f2(f1(5)))
    11
    >



### set\_safely

    // set array,map,set,weakmap,weakset, dict
    // only-if k exist

    var arr =[1,2,3]
    set_safely(arr,4,888)
    > var arr =[1,2,3]
    > set_safely(arr,4,888)
    > arr
    [ 1, 2, 3 ]
    > set_safely(arr,2,888)
    > arr
    [ 1, 2, 888 ]
    >


    > var d = {a:100,b:200}
    > set_safely(d,'c',888)
    > d
    { a: 100, b: 200 }
    >
    > set_safely(d,'a',888)
    > d
    { a: 888, b: 200 }
    >

    var st = new Set([5,6,7])
    set_safely(st,8,888)
    > st
    Set(3) { 5, 6, 7 }
    >
    set_safely(st,6,888)
    > st
    Set(3) { 5, 7, 888 }
    >


### ary 

    > ary_split_at([10,20,30,40,50,60],2,5)
    [ [ 10, 20 ], [ 30, 40, 50 ], [ 60 ] ]
    >


### mat 

        > mat_transpo([[1,2],[3,4],[5,6]])
        [ [ 1, 3, 5 ], [ 2, 4, 6 ] ]
        >
        > mat_transpo([ [ 1, 3, 5 ], [ 2, 4, 6 ] ])
        [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]
        >



API
====

- fac\_bsc.is\_node()                                                       //if the runtime is nodejs

- fac\_bsc.add\_repr(Cls,repr\_func,...other\_repr\_func\_args)             //[util.inspect.custom] in nodejs , else .prototype.repr
- fac\_bsc.add\_string\_tag(Cls,repr\_func,...other\_repr\_func\_args)      //get \[Symbol.toStringTag\]() {}


- fac\_bsc.optional\_chaining(obj,...keys)        //same as ?., for api-compatible 
- fac\_bsc.nullish(a,b);                          // same as ?? ,for api-compatible
- fac\_bsc.nc(a,b);                               //same as nullish, for api-compatible


- fac\_bsc.is\_null(o);
- fac\_bsc.is\_undefined(o);
- fac\_bsc.is\_nullish(o);         //null or undefined
- fac\_bsc.is\_nothing(o);         //Nil None nil nullptr NULL empty hole, refer to CONSTS  
- fac\_bsc.is\_assignable(o);      //o !== noexist

- fac\_bsc.is\_symbol(o) 
- fac\_bsc.is\_bool(o) 
- fac\_bsc.is\_num(o) 
- fac\_bsc.is\_float(o) 
- fac\_bsc.is\_int(o) 
- fac\_bsc.is\_nan(o) 
- fac\_bsc.is\_infinity(o)  
- fac\_bsc.is\_abnormal\_num(o) 
- fac\_bsc.is\_normal\_num(o) 
- fac\_bsc.is\_str(o) 
- fac\_bsc.is\_prim(o) 
- fac\_bsc.is\_bigint(o) 
- fac\_bsc.is\_ary(o) 

- fac\_bsc.is\_u8ary(o)            
- fac\_bsc.is\_buf(o)            //buffer is same as u8ary 
- fac\_bsc.is\_u8cary(o)         //clamped uint8-array
- fac\_bsc.is\_u16ary(o) 
- fac\_bsc.is\_u32ary(o) 
- fac\_bsc.is\_i8ary(o) 
- fac\_bsc.is\_i16ary(o) 
- fac\_bsc.is\_i32ary(o) 
- fac\_bsc.is\_f32ary(o)
- fac\_bsc.is\_f64ary(o) 
- fac\_bsc.is\_bu64ary(o) 
- fac\_bsc.is\_bi64ary(o) 
- fac\_bsc.is\_typed\_ary(o)

- fac\_bsc.is\_set(o) 
- fac\_bsc.is\_map(o) 
- fac\_bsc.is\_wkset(o) 
- fac\_bsc.is\_wkmap(o) 
- fac\_bsc.is\_wkref(o) 
- fac\_bsc.is\_weak(o)

- fac\_bsc.is\_dict(o)      //object NOT  array|typed-array|weak|set|map|cls|func|promise|proxy|
                            //            regex|date|data-view|generator

- fac\_bsc.is\_normal\_dict(o)        //dict but NOT promise| proxy | generator


- fac\_bsc.is\_promise(o)
- fac\_bsc.is\_proxy(o)               //only work in nodejs 
- fac\_bsc.is\_sync\_generator(o)
- fac\_bsc.is\_async\_generator(o)
- fac\_bsc.is\_generator(o)
- fac\_bsc.is\_ppg(o)                    //promise| proxy | generator


- fac\_bsc.is\_regex(o) 
- fac\_bsc.is\_cls\_or\_func(o)  
- fac\_bsc.is\_cls(o)
- fac\_bsc.is\_async\_func(o)
- fac\_bsc.is\_sync\_gen(o)
- fac\_bsc.is\_async\_gen(o)
- fac\_bsc.is\_gen(o)                       //sync\_gen  or async\_gen
- fac\_bsc.is\_normal\_func(o)              //func but NOT gen | async\_func
- fac\_bsc.is\_lambda(o)                    //()=>{} or async()=>{} 
- fac\_bsc.is\_func(o)                      // 
- fac\_bsc.is\_date(o) 
- fac\_bsc.is\_dv(o)                        //dataview
- fac\_bsc.is\_arybuf(o)                    //array-buf



- fac\_bsc.is\_enum\_iter\_leaf(o)      //when typed-array |array |map |set: return true if size/length === 0
                                        //when object : return true if Object.keys(o).length === 0
                                        //others return false

- fac\_bsc.is\_falsy(o)                 // '',0,0n,[],{},and empty Set/Map and empty typed-array
- fac\_bsc.is\_truthy(o)


- fac\_get\_dtype(o)                    //return a string of data-type
                                        //refer to CONSTS DTYPE_NUM
- fac\_get\_dtype\_num(o)               //return a big-int number  of data-type


- fac\_bsc.iflet(cond,rslt,cond,rslt,....else) 
- fac\_bsc.ifrtrn(
                     ctx,
                     cond_func0,action0,
                     cond_func1,action1,
                     ....
                     cond_funck,actionk,
                     default_action
                 )


- fac\_bsc.ifdo(
                     ctx,
                     cond_func0,action0,
                     cond_func1,action1,
                     ....
                     cond_funck,actionk,
                     default_action
                 )


- fac\_bsc.creat\_ifgoto(
                     cond_func0,action0,
                     cond_func1,action1,
                     ....
                     cond_funck,actionk,
                     default_action
                 );
            
            //var ifgoto = creat_ifgoto(...);
            //ifgoto(ctx);
            //ifgoto.reset()





- fac\_bsc.forof(o)                           //if o has [Symbol.iterator] return o, 
                                              //else try for-in and return a generator
                                              //for api-compatible and consistency

- fac\_bsc.fary(funcs,param)
- fac\_bsc.fchain(param,...funcs)        
                                  // fary([f1,f2,f3],param)
                                  // equals  f3(f2(f1(param)))

- fac\_artrn(f,...params)         //for-impl-performance-test-purpose , normally USELESS



- fac\_bsc.set\_safely(o,key-or-index,v) 
                                  //set [array|map|set|weakmap|weakset|dict] element at k-or-i
                                  //only-if k-or-i exist


- fac\_bsc.creat\_reserved(...kvpairs)       //creat global reserved variables, similar to usage of undefined

- fac\_bsc.creat\_id()                       // if nodejs call crypto.randomUUID, else using nanoid
                                             //nanoid is slightly faster than uuidv4 
- fac\_bsc.get\_abbr(id)                     // the first-8 of a uuid
- fac\_bsc.creat\_bigint\_id()               //convert uuid to a bigint 
- fac\_bsc.creat\_nodash\_id()               //remove dash in uuid
- fac\_bsc.creat\_4int\_id\_ary()            //convert uuid to 4-int-array

- fac\_bsc.SNidPool                          //a int or bigint ID, 
                                             //useful when using adj-table as data structure 

                      
                       //similiar with SNidPool,used in fixed-size scenario;
                       //these are used in fixed-size array-pool ,  
                       // useful when using sharedArrayBuffer,otherwise useless                             
- fac\_bsc.AidPool    //(Array);
- fac\_bsc.T8AidPool  //(Uint8Array);
- fac\_bsc.T16AidPool //(Uint16Array);
- fac\_bsc.T32AidPool //(Uint32Array);
- fac\_bsc.T64AidPool //(BigUint64Array);


- fac\_bsc.jdcp(jsond)                            //JSON.parse(JSON.stringify(jsond))
- fac\_bsc.jrplc(jsond,f)                         // f: (val,index,key,parent) => {...}
- fac\_bsc.jmap(jsond,f)                          // f: (val,index,key,parent) => {...}

- fac\_bsc.jkvl(j,include\_self=true)               // [[str\_key,value].....]
- fac\_bsc.jlength(j,include\_self=true)            // 
- fac\_bsc.jprim\_length(j,include\_self=true)      // not-array and not-dict
- fac\_bsc.jnonprim\_length(j,include\_self=true)   // array-or-dict,
- fac\_bsc.jleaf\_length(j,include\_self=true)      // not-array and not-dict and [] and {}
- fac\_bsc.jnonleaf\_length(j,include\_self=true)   // array-or-dict but-not []-or-{}



- fac\_bsc.jgen(j)                       //yield [val,index,key,parent,is\_prop,is\_ele]
- fac\_bsc.jflat(j)                      //[[key\_list,val]...]



- fac\_bsc.unescq(s)           //JSON.parse('"'+s+'"')

- fac\_bsc.typof(o,str);
- fac\_bsc.instof(o,Instance);

- fac\_bsc.eqany(o,...opts);     // opts.includes(o)
                                 // this is used to avoid too many  ===
                                 // coz too-many === will make code unreadable, too long


- fac\_bsc.d2kvlist(d)            // {a:100,b:200} => [['a','b'],[10,200]]
- fac\_bsc.kvlist2d(kl,vl)        // [['a','b'],[10,200]] => {a:100,b:200}
- fac\_bsc.dlngth(d)              // {a:100,b:200} => 2
- fac\_bsc.dsome(d,...ks)         //  dsome({a:100,b:200,c:300},'a','c') => {a:100,c:300}
- fac\_bsc.drekey(d,...ks)        //  drekey({a:100,b:200,c:300},'A','B','C') => {A:100,B:200,C:300}
- fac\_bsc.dreval(d,...vs)        //  dreval({a:100,b:200,c:300},10,20,30) => {a:10,b:20,c:30}


- fac\_bsc.SimpleStack         //Just Array with a  lst(top) setter/getter  to handle last-element
                               //and generator from-last-to-first

- fac\_bsc/SimpleMirr

- fac\_bsc.ary\_lst\_index(ary) {return(ary.length-1)}
- fac\_bsc.ary\_lsti(ary)       //same as ary\_lst\_index

- fac\_bsc.get\_ary\_lst(ary) {return(ary[ary.length-1])}
- fac\_bsc.ary\_glst(ary)      //same as get\_ary\_lst

- fac\_bsc.set\_ary\_lst(ary,v) {ary[ary.length-1] = v}
- fac\_bsc.ary\_slst(ary)      //same as set\_ary\_lst


- fac\_bsc.ary\_ibfr(ary,index,v)   // insert before : ary.splice(index,0,v)
- fac\_bsc.ary\_iaft(ary,index,v)   // insert after  : ary.splice(index+1,0,v)

- fac\_bsc.ary\_rm(ary,index)       // remove at     : ary.splice(index,1)

- fac\_bsc.ary\_fltrg(ary,fltr,not=false)   //Iterator   ,similar as filter, just yield [r,i]
                                    // fltr : (r:any,i:number) => Boolean
                                    // type Entry = [any,number]     //tuple of (r,i)
                                    // type IteratorResult = {done: boolean;value:Entry} 
                                    // type Iterator = {
                                    //    next(value?: any): IteratorResult;            
                                    //    return?(value?: any): IteratorResult;
                                    //    throw?(e?: any): IteratorResult;
                                    //  } 

- fac\_bsc.ary\_freq(ary,v)         // ary=[2,2,3,2,4]      ary\_freq(ary,2)  : 3

- fac\_bsc.ary\_foreach\_brk(arr,f,brkf=(r,i)=\>false)       
- fac\_bsc.ary\_foreach\_skip(arr,f,skipf=(r,i)=\>false)     


- fac\_bsc.rename\_func(f,new\_name)

- fac\_bsc.rename\_cls(Cls,new\_name)
- fac\_bsc.def\_cls\_instof(Cls,f)     // f: (Cls,inst)=\>Boolean

- fac\_bsc.add\_method(Cls,method)
- fac\_bsc.rm\_method(Cls,method\_name)



- class //the below   
        //for dynamic-add from outside, #priv can NOT support dynamic-add from outside;
        

- fac\_bsc.add\_getter(cls,prop,getter,...priv\_props)       //getter : (that,priv\_props)=\>any
- fac\_bsc.add\_setter(cls,prop,setter,...priv\_props)       //setter : (that,v,priv\_props)=>{...}
- fac\_bsc.add\_gseter(cls,prop,getter,setter,...priv\_props) // add both getter AND setter 

- fac\_bsc.add\_priv\_prop(cls,prop)          //(cls,prop)=>{priv\_initer,priv\_prop}
                                              //add public_getter AND public_setter for one prop
                                              //for compatible, if without #priv support



- fac\_bsc.DP          //abbr of Object.defineProperty
- fac\_bsc.DPV(o,k,v)  //abbr of Object.defineProperty(o,k,{value:v})          
- fac\_bsc.gopds        //abbr of Object.getOwnPropertyDescriptors
- fac\_bsc.gopes        //abbr of Object.entries(Object.getOwnPropertyDescriptors(o))


CONSTS
======

        > fac_bsc
        {
          ////the below is just for api-compatible when migrating some code from other coding language  
          
          Nil: [class Nil],
          nfunc: [Function: nfunc],
          None: None,
          nil: [Object: null prototype] {},
          nullptr: [Object: null prototype] {},
          NULL: [Object: null prototype] {},
          
          //// the 4 global symbol to avoid conflicting with undefined , just a semantic-undefined

          empty: Symbol("empty"),
          unknown: Symbol("unknown"),
          impossible: Symbol("impossible"),
          maybe: Symbol("maybe"),
          any:   Symbol("any"),
          hole:  Symbol("hole"),  // for special handling  <empty slot> in Array  

          ////to avoid conflicting with null, just a semantic-null-sign
          root: Symbol("root")

          ///to present noexist, such as when arr=[0,1,2]  arr[4]
          ///currently   js will return undefined  which ambigious with <empty slot>
          ///noexist should be NOT  assignable , 
          /// its IM-possible to implement {assignable:false}  in JS layer
          /// so just use a symbol 
          
          noexist: Symbol("noexist")

          //// for add_repr or add_string_tag

          NUL: '\x00',
          NBSP: ' ',
          LS: '�',
          PS: '�',
          ZWNJ: '‌',
          ZWJ: '‍',
          BOM: '',
        }
        >



        STATE_LABEL_DICT: {
          init: Symbol(init),
          ready: Symbol(ready),
          waiting: Symbol(waiting),
          executing: Symbol(executing),
          pending:   Symbol(pending),
          paused:    Symbol(paused),
          skipped:   Symbol(skipped),
          stopped:   Symbol(stopped),
          finished: Symbol(finished),
          resolved: Symbol(resolved),
          rejected: Symbol(rejected)
          eof: Symbol(eof)
        },

        const DTYPE_NUM = {
            'undefined':                                                0b1n,
            'null':                                                    0b10n,
            'symbol':                                                 0b100n,
            'bool':                                                  0b1000n,
            'int':                                                  0b10000n,
            'float':                                               0b100000n,
            'nan':                                                0b1000000n,
            'infinity':                                          0b10000000n,
            'str':                                              0b100000000n,
            'bigint':                                          0b1000000000n,
            'u8ary':                                          0b10000000000n,
            'u8cary':                                        0b100000000000n,
            'u16ary':                                       0b1000000000000n,
            'u32ary':                                      0b10000000000000n,
            'i8ary':                                      0b100000000000000n,
            'i16ary':                                    0b1000000000000000n,
            'i32ary':                                   0b10000000000000000n,
            'f32ary':                                  0b100000000000000000n,
            'f64ary':                                 0b1000000000000000000n,
            'bu64ary':                               0b10000000000000000000n,
            'bi64ary':                              0b100000000000000000000n,
            'ary':                                 0b1000000000000000000000n,
            'set':                                0b10000000000000000000000n,
            'map':                               0b100000000000000000000000n,
            'wkset':                            0b1000000000000000000000000n,
            'wkmap':                           0b10000000000000000000000000n,
            'wkref':                          0b100000000000000000000000000n,
            'regex':                         0b1000000000000000000000000000n,
            'date':                         0b10000000000000000000000000000n,
            'dv':                          0b100000000000000000000000000000n,
            'arybuf':                     0b1000000000000000000000000000000n,
            'sarybuf':                   0b10000000000000000000000000000000n,
            'promise':                  0b100000000000000000000000000000000n,
            'proxy':                   0b1000000000000000000000000000000000n,
            'sync_generator':         0b10000000000000000000000000000000000n,
            'async_generator':       0b100000000000000000000000000000000000n,
            'normal_dict':          0b1000000000000000000000000000000000000n,
            'cls':                 0b10000000000000000000000000000000000000n,
            'sync_gen':           0b100000000000000000000000000000000000000n,
            'async_gen':         0b1000000000000000000000000000000000000000n,
            'async_func':       0b10000000000000000000000000000000000000000n,
            'normal_func':     0b100000000000000000000000000000000000000000n,
        }

        //// this is used to implement kvtree, which can uniform map/dict/array/set
        ////  which support both nest-at-key-position and nest-at-value-position
        ////  its a super-table structure

        STYPE_DICT: { 
            root: -1, 
            ele: 0,     //element of array
            prop: 1,    //prop of dict
            stele: 2,   //element of set
            mpk: 3,     //key of mp-element
            mpv: 4,     //value of mp-element
            leaf: 5 
        },


        GLOBAL_ERROR_DICT = {
            noexist_is_not_assignable:new Error("noexist_is_not_assignable")
        }


### Class

#### for dynamic change.  used in testbed

    class B {}
    var b = new B()
    > b instanceof B
    true
    >

    def_cls_instof(B,(Cls,inst)=>false)
    > b instanceof B
    false
    >
    def_cls_instof(B,(Cls,inst)=>true)
    > b instanceof B
    true
    >

####  for compatible when #priv is NOT suitable

            class A {}

            var {priv_initer,priv_prop} = add_priv_prop(A,'pub')
            > priv_initer
            [Function: priv_initer]
            > priv_prop
            Symbol(pub)
            >
            > var a = new A()

            priv_initer(a,999999)


            > a.pub
            999999
            > a.pub =8888
            8888
            > a
            A {}
            > a.pub
            8888
            >

            > gopds(a)
            {
              [Symbol(pub)]: {
                value: 999999,
                writable: true,
                enumerable: false,
                configurable: true
              }
            }
            >


LICENSE
=======
- ISC 
