const {FLAG_DICT} = require("nv-data-tree-actdef");

function _sdfs_next(condf,nd) {
    if(!condf(nd)) {
        return(nd.$sdfs_next_)
    } else {
        let rsib = nd.$rsib_;
        return(
            (rsib !== null)?rsib:nd.$rsib_of_fst_ance_having_rsib_
        )
    }
}

function * _gen_sdfs_next(condf,nd) {
    let drmost  = nd.$drmost_;
    let term = drmost.$sdfs_next_;
    while(nd!==term) {
        yield(nd);
        nd = _sdfs_next(condf,nd);
    }
}

////

function _sedfs_next(condf,nd,flag) {
    if(!condf(nd)) {
        return(nd.$sedfs_next(flag))
    } else {
        if(flag === FLAG_DICT.open) {
            return([nd,'close'])
        } else {
            return(nd.$sedfs_next_after_close_)
        }
    }
}

function * _gen_sedfs_next(condf,nd) {
    let flag = 'open';
    let [term,tflag] = nd.$sedfs_next(FLAG_DICT['close']);
    while(nd!==term || flag!==tflag) {
        yield([nd,flag]);
        [nd,flag] = _sedfs_next(condf,nd,FLAG_DICT[flag])
    }
}


function add_cond_leaf_sdfs_next(Node) {
    Node.prototype.$cond_leaf_sdfs_next = function(condf) {
        return(_sdfs_next(condf,this))
    }
}

function add_gen_cond_leaf_sdfs_next(Node) {
    Node.prototype.$gen_cond_leaf_sdfs_next = function *(condf) {
        yield * _gen_sdfs_next(condf,this)
    }
}


function add_cond_leaf_sedfs_next(Node) {
    Node.prototype.$cond_leaf_sedfs_next = function(condf,flag) {
        return(_sedfs_next(condf,this,flag))
    }
}

function add_gen_cond_leaf_sedfs_next(Node) {
    Node.prototype.$gen_cond_leaf_sedfs_next = function *(condf) {
        yield * _gen_sedfs_next(condf,this)
    }
}


////
function add_method_for_block(Node) {
    let condf = (nd)=>nd.$is_blocked()|| nd.$is_leaf();
    Node.prototype.$is_ance_blocked = function () {
        return(!this.$is_self_blocked() && this.$is_blocked())
    }
    Node.prototype.$is_blocked = function () {
        let blocked_nd = this.$blocked_;
        return(blocked_nd!==null)
    }
    Object.defineProperty(
        Node.prototype,
        '$blocked_',
        {
            get:function() {
                if(this.$is_self_blocked()) {
                    return(this)
                } else {
                     let g = this.$gen_ance()
                     for(let each of g) {
                         if(each.$is_self_blocked()) {
                             return(each)
                         }
                     }
                     return(null)
                }
            }
        }
    );
    Node.prototype.$gen_sdfs_next_ignore_blocked = function *() {
        let drmost  = this.$drmost_;
        let term = drmost.$sdfs_next_;
        let nd = this;
        while(nd!==term) {
            yield(nd);
            nd = _sdfs_next(condf,nd);
        }
    }
    Object.defineProperty(
        Node.prototype,
        '$sdfs_next_ignore_blocked_',
        {
            get:function() {
                return(_sdfs_next(condf,this))
            }
        }
    );
    Object.defineProperty(
        Node.prototype,
        '$sdfs_ignore_blocked_',
        {
            get:function() {
                let g = this.$gen_sdfs_next_ignore_blocked();
                return(Array.from(g))
            }
        }
    );
    ////
    Node.prototype.$gen_sedfs_next_ignore_blocked = function *() {
        let flag = 'open';
        let nd = this;
        let [term,tflag] = nd.$sedfs_next(FLAG_DICT['close']);
        while(nd!==term || flag!==tflag) {
            yield([nd,flag]);
            [nd,flag] = _sedfs_next(condf,nd,FLAG_DICT[flag])
        }
    }
    Object.defineProperty(
        Node.prototype,
        '$sedfs_next_ignore_blocked_when_open_',
        {
            get:function() {
                return(_sedfs_next(condf,this,FLAG_DICT.open))
            }
        }
    );
    Object.defineProperty(
        Node.prototype,
        '$sedfs_next_ignore_blocked_when_close_',
        {
            get:function() {
                return(_sedfs_next(condf,this,FLAG_DICT.close))
            }
        }
    );
    Object.defineProperty(
        Node.prototype,
        '$sedfs_ignore_blocked_',
        {
            get:function() {
                let g = this.$gen_sedfs_next_ignore_blocked();
                return(Array.from(g))
            }
        }
    );
}



module.exports = {
    add_cond_leaf_sdfs_next,
    add_gen_cond_leaf_sdfs_next,
    add_cond_leaf_sedfs_next,
    add_gen_cond_leaf_sedfs_next,
    add_method_for_block,
}




