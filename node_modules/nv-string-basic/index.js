const {is_ary,is_str,is_regex} = require("nv-facutil-basic");

function prepend(s,width,pad=" ",force=false) {
    let lngth = s.length;
    if(lngth <= width) {
        let prefix = pad.repeat(width-lngth)
        return(prefix+s)
    } else {
        if(force) {
            return(s.substr(lngth-width))
        } else {
            return(s)
        }
    }
}

function append(s,width,pad=" ",force=false) {
    let lngth = s.length;
    if(lngth <= width) {
        let suffix = pad.repeat(width-lngth)
        return(s+suffix)
    } else {
        if(force) {
            return(s.substr(0,width))
        } else {
            return(s)
        }
    }
}

function prepend_num(n,radix,width,pad="0",force=false) {
    let s = n.toString(radix);
    return(prepend(s,width,pad,force))
}

function append_num(n,radix,width,pad="0",force=false) {
    let s = n.toString(radix);
    return(append(s,width,pad,force))
}

const REGEX_BDIGIT_CHAR = /^[0-1]$/
const REGEX_BDIGIT_STR = /^[0-1]+$/
const REGEX_ODIGIT_CHAR = /^[0-7]$/
const REGEX_ODIGIT_STR = /^[0-7]+$/
const REGEX_DDIGIT_CHAR = /^[0-9]$/
const REGEX_DDIGIT_STR = /^[0-9]+$/
const REGEX_HDIGIT_CHAR = /^[0-9a-fA-F]$/
const REGEX_HDIGIT_STR = /^[0-9a-fA-F]+$/


function is_bdigit_ch(ch) {
    return(REGEX_BDIGIT_CHAR.test(ch))
}

function is_bdigit_str(s) {
    return(REGEX_BDIGIT_STR.test(s))
}


function is_odigit_ch(ch) {
    return(REGEX_ODIGIT_CHAR.test(ch))
}

function is_odigit_str(s) {
    return(REGEX_ODIGIT_STR.test(s))
}


function is_ddigit_ch(ch) {
    return(REGEX_DDIGIT_CHAR.test(ch))
}

function is_ddigit_str(s) {
    return(REGEX_DDIGIT_STR.test(s))
}

function is_hdigit_ch(ch) {
    return(REGEX_HDIGIT_CHAR.test(ch))
}

function is_hdigit_str(s) {
    return(REGEX_HDIGIT_STR.test(s))
}


const LOWER_CASE_ATOZ_STR = 'abcdefghijklmnopqrstuvwxyz'
const UPPER_CASE_ATOZ_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 

function _creat_char_series_md(s,offset=0) {
    let entries = Object.entries(Array.from(s));
    entries = entries.map(e=>[parseInt(e[0])+offset,e[1]]);
    let d0 =  Object.fromEntries(entries);
    entries.reverse();
    let d1 = Object.fromEntries(entries);
    Object.assign(d0,d1);
    return(d0)
}


const LOWER_CASE_ATOZ_MD = _creat_char_series_md(LOWER_CASE_ATOZ_STR,0)
const UPPER_CASE_ATOZ_MD = _creat_char_series_md(UPPER_CASE_ATOZ_STR,0)



function is_ndigit_ch(n,ch) {
    let regex;
    if(n<=10) {
        n=n.toString();
        regex = new RegExp(`^[0-${n}]\$`)
    } else {
        let md = _creat_char_series_md(UPPER_CASE_ATOZ_STR,n-10);
        let ulst = md[n-10];
        let llst = ulst.toLowerCase();
        regex = new RegExp(`^[0-${n}a-${llst}A-${ulst}]\$`)
    }
    return(regex.test(ch));
}

function is_ndigit_str(n,s) {
    let regex;
    if(n<=10) {
        n=n.toString();
        regex = new RegExp(`^[0-${n}]+\$`)
    } else {
        let md = _creat_char_series_md(UPPER_CASE_ATOZ_STR,n-10);
        let ulst = md[n-10];
        let llst = ulst.toLowerCase();
        regex = new RegExp(`^[0-${n}a-${llst}A-${ulst}]+\$`)
    }
    return(regex.test(s));
}



function slength(s) {return(Array.from(s).length)}
function u16length(s) {return(s.length)}
function blength(s) {return(Buffer.from(s).length)}


function to_str(o,cjson=true) {
    if(typeof(o) === 'string') {
        return(o)
    }else if(o === undefined) {
        return('undefined')
    } else if(o === null) {
        return('null')
    } else if(typeof(o) === 'number') {
        return(o.toString())
    } else if (typeof(o) === 'bigint') {
        return(o.toString()+'n')
    } else if(typeof(o) === 'symbol') {
        return(o.description)
    } else if(o?.[util?.inspect?.custom]){
        return(o[util.inspect.custom]())
    } else {
        let _f = function (o) {
            if(typeof(o.toString) === 'function') {
                return(o.toString())
            } else {
            }
        }
        try {
            if(cjson){
                s = JSON.stringify(o)
            } else {
                s = JSON.stringify(o,null,4)
            }
            if(typeof(s) === 'string') {return(s)} else {return(_f(o))}
        } catch(err) {return(_f(o))}
    }
}





function _tag(args,quasis,expressions) {
    let s = quasis[0]
    let lngth = expressions.length;
    for(let i=0;i<lngth;i++) {
        let arg = args[expressions[i]]
        if(arg !== undefined) {
            s = s+arg+quasis[i+1]
        } else {
            s = s+''+quasis[i+1]
        }
    }
    return(s)
}

function stmpl(quasis,...expressions) {
    function _f(...args) {return(_tag(args,quasis,expressions))}
    return(_f)
}

function dtmpl(quasis,...expressions) {
    function _f(d) {return(_tag(d,quasis,expressions))}
    return(_f)
}



const BIGINT_REGEX = /^[\-\+]?[0-9]+n$/
const BIGINT_BIN_REGEX = /^[\-\+]?0[bB][0-1]+n$/
const BIGINT_OCT_REGEX = /^[\-\+]?0[oO][0-7]+n$/
const BIGINT_HEX_REGEX = /^[\-\+]?0[xX][0-9a-fA-F]+n$/

function is_bigint_str(s) {
    return(
        BIGINT_REGEX.test(s) ||
        BIGINT_BIN_REGEX.test(s) ||
        BIGINT_OCT_REGEX.test(s) ||
        BIGINT_HEX_REGEX.test(s)
    )
}



const DEC_REGEX = /^[\-\+]?[0-9]+$/
const POS_DEC_REGEX = /^\+?[0-9]+$/
const NEG_DEC_REGEX = /^\-[0-9]+$/

const BIN_REGEX = /^[\-\+]?0[bB][0-1]+$/
const OCT_REGEX = /^[\-\+]?0[oO][0-7]+$/
const HEX_REGEX = /^[\-\+]?0[xX][0-9a-fA-F]+$/


function is_jsint_str(s) {
    return(DEC_REGEX.test(s) || HEX_REGEX.test(s))
}

const RADIX_DICT = {
    "0b":2,"0o":8,"0x":16,
    2:"0b",8:"0o",16:"0x"
}

function _parse_int(arr) {
    let sign;
    let radix;
    let rs;
    if(arr[0]==="+" || arr[0]==="-") {
        sign = arr[0];
        radix = RADIX_DICT[arr.slice(1,3).join("").toLowerCase()]    
        rs = arr.slice(3).join("").toLowerCase()
    } else {
        sign = "+"
        radix = RADIX_DICT[arr.slice(0,2).join("").toLowerCase()]  
        rs = arr.slice(2).join("").toLowerCase()
    }
    let i = parseInt(rs,radix);
    if(sign === "+") {return(+i)} else {return(-i)}
}


function parse_int(s)  {
    let arr = Array.from(s);
    if(DEC_REGEX.test(s)) {
        return(parseInt(s))
    } else if(
        BIN_REGEX.test(s) ||
        OCT_REGEX.test(s) ||
        HEX_REGEX.test(s) 
    ){
        return(_parse_int(arr))
    } else {
    }
}




function _new_floatd() {
    let d = {
        be:{sign:'',bd:'',dot:'',ad:''}, 
        ae:{sign:'',bd:'',dot:'',ad:''},
        state:"init"
    }
    return(d)
}


function _is_invalid_float_nonum(arr,s) {
    return(
        arr.length ===0 ||
        s==="." ||
        s==="-." ||
        s==="+." ||
        s==="+"  ||
        s==="-"  
    )
}

function _handle_sign(arr,d,cursor,mainstate) {
    if(arr[cursor] === '-' || arr[cursor] === '+') {
        d[mainstate].sign = arr[cursor];
        cursor = cursor+1;
    }
    return([arr,cursor])    
}


function _handle_fst(arr,d,cursor,mainstate) {
    d.state = mainstate +"bd"
    if(arr[cursor] === '.') {
        d[mainstate].bd = "0";
        d[mainstate].dot = "."
        d.state = mainstate +"ad"
    } else {
        if(!POS_DEC_REGEX.test(arr[cursor])) {
            return([true,cursor]);
        } else {
            d[mainstate].bd = arr[cursor]
        }
    }
    return([false,cursor+1])
}


function _handle_float_part(arr,d,cursor,mainstate) {
    let i;
    for(i=cursor;i<arr.length;i++) {
        if(arr[i] === ".") {
            if(d[mainstate].dot === ".") {
                return([true,i])
            } else {
                d[mainstate].dot = "."
                d.state = mainstate+"ad"
            }
        } else if(arr[i] === 'e' || arr[i] === 'E') {
            if(mainstate === "ae") {
                return([true,i])
            } else {
                d.state = "aebd";
                return([false,i+1])
            }
        } else if(POS_DEC_REGEX.test(arr[i])) {
            if(d.state === mainstate + "bd") {
                d[mainstate].bd = d[mainstate].bd + arr[i]
            } else {
                d[mainstate].ad = d[mainstate].ad + arr[i]
            }
        } else {
            return([true,i])
        }
    }
    return([false,i+1])
}


function _parse_floatd(d) {
    let be = d.be.sign + d.be.bd+d.be.dot+d.be.ad;
    let ae = d.ae.sign + d.ae.bd+d.ae.dot+d.ae.ad;
    let f;
    //不能只有符号
    if(
        be === "+"  || 
        be === "-"  ||
        ae === "+"  ||
        ae === "-"  
    ) {
        return;
    }
    //
    if(ae!=='') {
        if(d.ae.dot === ".") {
            let bef = parseFloat(be);
            let aef = parseFloat(ae);
            f = bef *(10 **aef);
        } else {
            f = parseFloat(be + 'e'+ae);
        }
    } else {f = parseFloat(be);}
    return(f)
}


function parse_float(s) {
    let d = _new_floatd();
    let arr = Array.from(s);
    ////invalid - begin
    if(_is_invalid_float_nonum(arr,s)) {return;}
    ////state be
    let cursor = 0;
    let rtrn = false;
    [arr,cursor] = _handle_sign(arr,d,cursor,'be');
    [rtrn,cursor] = _handle_fst(arr,d,cursor,'be');
    if(rtrn) {return;}
    ////be
    [rtrn,cursor] = _handle_float_part(arr,d,cursor,'be');
    if(rtrn) {return;}
    ////ae
    [arr,cursor] = _handle_sign(arr,d,cursor,'ae');
    [rtrn,cursor] = _handle_float_part(arr,d,cursor,'ae');
    if(rtrn) {return;}
    //
    return(_parse_floatd(d))
}



const NUM_TYPE_DICT = {
    Integer:6,
    Float:7,
    BigInt:8,
    PosInfinity:9,
    NegInfinity:10,
    NaN:11,
    6:"Integer",
    7:"Float",
    8:"BigInt",
    9:"PosInfinity",
    10:"NegInfinity",
    11:"NaN"
}


function parse_abnormal_num(s,with_type=false) {
    let d = {value:undefined,type:undefined}
    if(s === "+Infinity" || s === "Infinity") {
        d.value = Infinity;
        d.type = NUM_TYPE_DICT.PosInfinity;
    } else if (s === "-Infinity") {
        d.value = -Infinity;
        d.type = NUM_TYPE_DICT.NegInfinity;
    } else if (s === "NaN" || s === "+NaN" || s === "-NaN") {
        d.value = NaN;
        d.type = NUM_TYPE_DICT.NaN
    } else {
    }
    if(with_type) {
        return(d)
    } else {
        return(d.value)
    }
}

function parse_num(s,with_type=false) {
    let d = {value:undefined,type:undefined}
    if(is_bigint_str(s)) {
        d.value = BigInt(s.substr(0,s.length-1));
        d.type = NUM_TYPE_DICT.BigInt;
    } else {
        let n = parse_int(s);
        if(n !== undefined) {
            d.value = n;
            d.type = NUM_TYPE_DICT.Integer;
        } else {
            n = parse_float(s);
            if(n !== undefined) {
                d.value = n;
                d.type = NUM_TYPE_DICT.Float;
            } else {
                n = parse_abnormal_num(s,with_type=true)
                if(n.value !== undefined) {
                    d = n; 
                } else {
                }
            }
        }
    }
    if(with_type) {return(d)} else {return(d.value)}
}

const S0_TYPE_DICT = {
    "UndefinedLiteral": 0,
    "NullLiteral": 1,
    "FalseLiteral": 3,
    "TrueLiteral": 4,
    "StringLiteral": 12,
}


const {unknown} = require("nv-facutil-basic");

const _DFLT_PARSE0_CFG =  {
    only_value:true,
    with_value:true,
    with_type:false,
    unknown_as_string:false
}


function parse0(s,
    cfg= {
        only_value:true,
        with_value:true,
        with_type:false,
        unknown_as_string:false
    }
) {
    let ncfg = JSON.parse(JSON.stringify(_DFLT_PARSE0_CFG));
    Object.assign(ncfg,cfg);
    let {only_value,with_value,with_type,unknown_as_string} = ncfg;
    let d = {
        value:unknown,
        type:unknown
    }
    if(s === 'undefined') {
        d.value = undefined;
        d.type = S0_TYPE_DICT.UndefinedLiteral;
    } else if(s === 'null') {
        d.value = null;
        d.type = S0_TYPE_DICT.NullLiteral;
    } else if(s === 'false') {
        d.value = false;
        d.type = S0_TYPE_DICT.FalseLiteral;
    } else if(s === 'true') {
        d.value = true;
        d.type = S0_TYPE_DICT.TrueLiteral;
    } else {
        let n = parse_num(s,true);
        if(n.type===undefined) {
            if(unknown_as_string) {
                d.value = s;
                d.type = S0_TYPE_DICT.StringLiteral;
            } else {
                d.value = s;
                d.type = unknown;
            }
        } else {
            d.value = n.value;
            d.type = n.type;
        }
    }
    if(only_value) {
        return(d.value)
    } else {
        if(with_type) {} else {delete d.type}
        if(with_value) {} else {delete d.value}
        return(d)
    }
        
}

parse0.unknown = unknown;


////

function reverse(s) {
    let ary = Array.from(s);
    ary.reverse();
    return(ary.join(''))
}

////
const wschar = require("nv-char-whitespace");
const WSTR = wschar.WS_CH_ARR.join("");
const DFLT_TRIM_LEFT_REGEXP = new RegExp(`^[${WSTR}]+`); 

function _ftrim_left(s,condf) {
    let c =0;
    for(let ch of s) {
        if(condf(ch)) {
        } else {
            break
        }
        c = c +1
    }
    return(s.slice(c))
}

function trim_left(s,cond=DFLT_TRIM_LEFT_REGEXP) {
    if(is_ary(cond)) {
        cond = cond.map(r=>`^(${r})+`);
        let regex_str = cond.join('|');
        return(s.replace(new RegExp(regex_str),""))
    } else if(is_str(cond)) {
        let regex_str = `^[${cond}]+`
        return(s.replace(new RegExp(regex_str),""))
    } else if(is_regex(cond)) {
        return(s.replace(cond,"")) 
    } else {
        return(_ftrim_left(s,cond))
    }
}

const DFLT_TRIM_RIGHT_REGEXP = new RegExp(`[${WSTR}]+\$`);

function trim_right(s,cond=DFLT_TRIM_RIGHT_REGEXP) {
    if(is_ary(cond)) {
        cond = cond.map(r=>`(${r})+\$`);
        let regex_str = cond.join('|');
        return(s.replace(new RegExp(regex_str),""))
    } else if(is_str(cond)) {
        let regex_str = `[${cond}]+\$`
        return(s.replace(new RegExp(regex_str),""))
    } else if(is_regex(cond)) {
        return(s.replace(cond,""))
    } else {
        s = reverse(s);
        s = _ftrim_left(s,cond);
        s = reverse(s);
        return(s)
    }
}

const DFLT_TRIM_REGEXP = new RegExp(`(^[${WSTR}]+)|([${WSTR}+]\$)`)

function trim(s,cond=DFLT_TRIM_REGEXP) {
    s = trim_left(s,cond)
    s = trim_right(s,cond)
    return(s)
}

////

function * _gen_split_sec(sec) {
    let [si,ei] = sec;
    for(let i=si+1;i<ei;i++) {
        yield([[si,i],[i,ei]])
    }
}


const ary_combo = require("nv-array-combo");

function * gen_split_two(s) {
    let ary = Array.from(s);
    let sec = [0,ary.length]
    let g = _gen_split_sec(sec)
    for(let each of g) {
        yield([s.slice(...each[0]),s.slice(...each[1])])
    }
}

function * gen_splits(s,n) {
    let ary = Array.from(s);
    let idxs = ary.map((r,i)=>i);
    let g = ary_combo.comb(idxs);
    for(let each of g) {
        if(each.length===n-1 || n === undefined) {
            let rslt = []
            let si =0;
            for(let idx of each) {
                rslt.push(s.slice(si,idx));
                si = idx;
            }
            rslt.push(s.slice(si,s.length));
            if(rslt[0].length>0) {yield(rslt)}
        }
    }
}

const _nonws_regex = /[\s]+/g

function nonws_length(s) {
    s = s.replace(_nonws_regex,"");
    return(Array.from(s).length)
}

function is_empty_line(s) {
    return(nonws_length(s)===0)
}

function lines(s) {return(s.split("\n"))}

function _u(ch,ignore_length_one=false) {
    let lngth = ch.length;
    if(lngth===1 && ignore_length_one) {
        return(ch)
    } else {
        let s =""
        for(let i=0;i<lngth;i++) {
            let c=ch.charCodeAt(i);
            let us = prepend_num(c,16,4);
            s=s+"\\u"+us
        }
        return(s);
    }
}



function u(s,ignore_length_one=false) {
    let arr = Array.from(s)
    arr = arr.map(ch=>_u(ch,ignore_length_one));
    return(arr.join(""))
}

function from_u(s) {
    let arr = Array.from(s);
    let rslt ="";
    let ucache = "";
    let state =0;
    for(let ch of arr) {
        if(state ===0) {
            if(ch === '\\') {
                state = 1;
            } else {
                rslt=rslt+ch;
            }
        } else if(state===1) {
            if(ch==='u') {
                state =2;
            } else {
                rslt=rslt+'\\';
                state = 0;
            }
        } else {
            if(ucache.length<4) {
                ucache = ucache+ch;
            } else if(ucache.length===4) {
                rslt = rslt + String.fromCharCode(parseInt(ucache,16));
                ucache="";
                if(ch==='\\') {state =1;} else {
                    rslt=rslt+ch;
                    state=0;
                }
            } else {
                //impossible
            }
        }
    }
    if(ucache.length===4) {
        rslt = rslt + String.fromCharCode(parseInt(ucache,16));
        ucache=""
    }
    return(rslt)
}



module.exports = {
    LOWER_CASE_ATOZ_STR,
    UPPER_CASE_ATOZ_STR,
    LOWER_CASE_ATOZ_MD,
    UPPER_CASE_ATOZ_MD,
    prepend,
    append,
    prepend_num,
    append_num,
    is_bdigit_ch,
    is_bdigit_str,
    is_odigit_ch,
    is_odigit_str,
    is_ddigit_ch,
    is_ddigit_str,
    is_hdigit_ch,
    is_hdigit_str,
    is_ndigit_ch,
    is_ndigit_str,
    slength,
    u16length,
    blength,
    to_str,
    stmpl,
    dtmpl,
    ////
    DEC_REGEX,
    POS_DEC_REGEX,
    NEG_DEC_REGEX,
    BIN_REGEX,
    OCT_REGEX,
    HEX_REGEX,
    RADIX_DICT,
    BIGINT_REGEX,
    BIGINT_BIN_REGEX,
    BIGINT_OCT_REGEX,
    BIGINT_HEX_REGEX,    
    is_bigint_str,
    is_jsint_str,
    parse_int,
    is_int_str:(s)=>(parse_int(s)!==undefined),
    is_ary_idx_str:(s)=>{
        let idx = parse_int(s);
        return(idx!==undefined && idx>=0 && idx<2*32-1)
    },
    parse_float,
    is_float_str:(s)=>(parse_float(s)!==undefined),
    NUM_TYPE_DICT,
    parse_abnormal_num,
    is_abnormal_num_str:(s)=>(parse_abnormal_num(s)!==undefined),
    parse_num,
    is_num_str:(s)=>(parse_num(s)!==undefined),
    S0_TYPE_DICT,
    parse0,
    ////
    reverse,
    ////
    DFLT_TRIM_LEFT_REGEXP,
    DFLT_TRIM_RIGHT_REGEXP,
    DFLT_TRIM_REGEXP,
    trim_left,
    trim_right,
    trim,
    ////
    gen_splits,
    gen_split_two,
    ////
    nonws_length,
    is_empty_line,
    lines,
    ////
    u,
    from_u,
    ////
}


